@{
    Layout = null;
}

<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3.v4.js"></script>

    <style>
        body {
            margin: 0;
            font-family: "Lato", sans-serif;
        }

        /* Float four columns side by side */
        .column {
            float: left;
            width: 25%;
            /*padding:0px 0px 80px 370px;*/
        }

        /* Remove extra left and right margins, due to padding */
        .row {
            margin: 0 -5px;
        }

            /* Clear floats after the columns */
            .row:after {
                content: "";
                display: table;
                clear: both;
            }

        /* Responsive columns */
        @@media screen and (max-width: 600px) {
            .column {
                width: 100%;
                display: block;
                margin-bottom: 20px;
            }
        }
    </style>
    <script>
        function onload() {
            // set the dimensions and margins of the graph
            var margin = { top: 20, right: 20, bottom: 20, left: 40 },
                width = 260 - margin.left - margin.right,
                height = 200 - margin.top - margin.bottom;
            document.getElementById('my_dataviz').innerHTML = " ";
            // append the svg object to the body of the page
            var svg2 = d3.select("#my_dataviz")

              .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform",
                      "translate(" + margin.left + "," + margin.top + ")");

            //read data
            d3.csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv", function (data) {

                // Get the different categories and count them
                var categories = ["Almost Certainly", "Very Good Chance", "We Believe", "Likely", "About Even", "Little Chance", "Chances Are Slight", "Almost No Chance"]
                var n = categories.length

                // Compute the mean of each group
                allMeans = []
                for (i in categories) {
                    currentGroup = categories[i]
                    mean = d3.mean(data, function (d) { return +d[currentGroup] })
                    allMeans.push(mean)
                }

                // Create a color scale using these means.
                var myColor = d3.scaleSequential()
                  .domain([0, 100])
                  .interpolator(d3.interpolateViridis);

                // Add X axis
                var x = d3.scaleLinear()
                  .domain([-10, 120])
                  .range([0, 50]);
                var xAxis = svg2.append("g")
                  .attr("class", "xAxis")
                  .attr("transform", "translate(0," + height + ")")
                  .call(d3.axisBottom(x).tickValues([0, 25, 50, 75, 100]).tickSize(-height))

                // Add X axis label:
                svg2.append("text")
                    .attr("text-anchor", "end")
                    .attr("x", width)
                    .attr("y", height + 40)
                    .text("Performance status");

                // Create a Y scale for densities
                var y = d3.scaleLinear()
                  .domain([0, 0.25])
                  .range([height, 0]);

                // Create the Y axis for names
                var yName = d3.scaleBand()
                  .domain(categories)
                  .range([0, height])
                  .paddingInner(1)
                svg2.append("g")
                  .call(d3.axisLeft(yName).tickSize(0))
                  .select(".domain").remove()

                // Compute kernel density estimation for each column:
                var kde = kernelDensityEstimator(kernelEpanechnikov(7), x.ticks(40)) // increase this 40 for more accurate density.
                var allDensity = []
                for (i = 0; i < n; i++) {
                    key = categories[i]
                    density = kde(data.map(function (d) { return d[key]; }))
                    allDensity.push({ key: key, density: density })
                }

                // Add areas
                var myCurves = svg2.selectAll("areas")
                  .data(allDensity)
                  .enter()
                  .append("path")
                    .attr("class", "myCurves")
                    .attr("transform", function (d) { return ("translate(0," + (yName(d.key) - height) + ")") })
                    .attr("fill", function (d) {
                        grp = d.key;
                        index = categories.indexOf(grp)
                        value = allMeans[index]
                        return myColor(value)
                    })
                    .datum(function (d) { return (d.density) })
                    .attr("opacity", 0.7)
                    .attr("stroke", "#000")
                    .attr("stroke-width", 0.1)
                    .attr("d", d3.line()
                        .curve(d3.curveBasis)
                        .x(function (d) { return x(0); })
                        .y(function (d) { return y(d[1]); })
                    )

                // Animate X axis apparition
                x.range([0, width]);
                xAxis
                  .transition()
                  .duration(5000)
                  .call(d3.axisBottom(x).tickValues([0, 25, 50, 75, 100]).tickSize(-height))
                  .select(".domain").remove()

                // Animate densities apparition
                myCurves
                  .transition()
                  .duration(5000)
                  .attr("d", d3.line()
                      .curve(d3.curveBasis)
                      .x(function (d) { return x(d[0]); })
                      .y(function (d) { return y(d[1]); })
                  )

            })

            // This is what I need to compute kernel density estimation
            function kernelDensityEstimator(kernel, X) {
                return function (V) {
                    return X.map(function (x) {
                        return [x, d3.mean(V, function (v) { return kernel(x - v); })];
                    });
                };
            }
            function kernelEpanechnikov(k) {
                return function (v) {
                    return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
                };
            }
        }
    </script>
</head>



<body onload="onload()">

    <div class="grapheContainer">
        <svg id="svgchart"></svg>
        <p class="title">Marks of Pavana</p>
        <div id="my_dataviz"></div>

    </div>



</body>
</html>

